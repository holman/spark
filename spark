#!/usr/bin/env bash
#
# spark
# https://github.com/holman/spark
#
# Generates sparklines for a set of data.
#
# Here's a a good web-based sparkline generator that was a bit of inspiration
# for spark:
#
#   https://datacollective.org/sparkblocks
#
# spark takes a comma-separated list of data and then prints a sparkline out of
# it.
#
# Examples:
#
#   spark 1,5,22,13,53
#   # => ▁▁▃▂▇
#
#   spark 0,30,55,80,33,150
#   # => ▁▂▃▅▂▇
#
#   spark -h
#   # => Prints the spark help text.
set -e
debug='false'
fudge='0.5' # for rounding, when debug mode is not enabled

# Prints the help text for spark.
#
# Returns nothing.
help()
{
  cat <<-EOF

  USAGE:
    spark [comma,separated,value,list]

  EXAMPLES:
    spark 1,5,22,13,53
    ▁▁▃▂▇
    spark 0,30,55,80,33,150
    ▁▂▃▅▂▇
EOF
}

# The actual fun characters we are generating in the sparkline.
ticks=(▁ ▂ ▃ ▄ ▅ ▆ ▇)

# The numbers the user gave us.
numbers=()

# The sorted array of the numbers.
sorted=()

# This sets up our secondary array so we can actually generate the correct
# tick.
#
# Returns nothing.
setup_array() {
  # 3,6,2 => 2,3,6
  sorted=$(echo $1 | tr ',' '\n' | sort -k1,1n | paste -s -d',' -)

  # convert comma-separated string to array
  IFS=,
  sorted=($sorted)
  sort_min=${sorted[0]}
  sort_max=${sorted[${#sorted[@]} - 1]}
  numbers=($1)
}

# Find the distance between tiers so we know which tick to assign a character.
tier()
{
  number_of_ticks=${#ticks[@]}
  # Mustn't use $((..)) here because we need floating-point arithmetic
  distance=$( echo " ($sort_max - $sort_min) / ($number_of_ticks - 1)" | bc -l )
  echo $distance
}

# Determines what tick we should print for this number and prints it.
#
# Returns nothing.
print_tick()
{
  tier=$(tier)

  number=$1
  number_of_ticks=$(( ${#ticks[@]} - 1 ))
  # Don't use $((...)) here; we need floating-point arithmetic
  tick_index=$( echo " ($number - $sort_min) / $tier + $fudge " | bc -l )
  # + 0.5 in previous line causes 'truncate' to round off to the nearest integer
  if $debug ; then
    echo "$number $tick_index"
  else
    tick_index=$(truncate $tick_index)
    echo -n ${ticks[$tick_index]};
  fi
}

# $((...)) and printf both produce syntax errors on decimal numbers, so
# we will use a stone knife instead
truncate()
{
   echo $1 | sed -e 's/\..*$//'
}

# Iterate over all of our data and print them out.
#
# Returns nothing.
print_ticks()
{
  for number in ${numbers[@]}
  do
    print_tick $number
  done
  echo
}

while getopts ":hd" option; do
  case "$option" in
    h) help && exit ;;
#    [?]) echo "$OPTARG";;
    d) debug='true'; fudge='0'; shift $((OPTIND-1)) ;;
  esac
done

# Accept input from $1 or from the pipeline.
if test "$*" != ""
then
  data="$*"
else
  # check to see if stdin's a tty
  if [ -t 0 ]; then
    help
    exit
  fi

  read data
fi

# Trim spaces to allow input like '1, 2, 3'
data=$(echo $data | tr -s ' ' ',')

setup_array $data
print_ticks $data
